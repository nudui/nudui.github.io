<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>受命于天</title>
  <subtitle>既寿永昌- java、golang</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nudui.github.io/"/>
  <updated>2016-11-26T03:42:18.000Z</updated>
  <id>http://nudui.github.io/</id>
  
  <author>
    <name>受命于天</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务端开发-各种小问题</title>
    <link href="http://nudui.github.io/2016/11/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E7%9F%AD%E4%BF%A1%E3%80%81%E5%AD%98%E5%82%A8%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/"/>
    <id>http://nudui.github.io/2016/11/26/服务端开发-短信、存储资源限制/</id>
    <published>2016-11-25T17:39:57.000Z</published>
    <updated>2016-11-26T03:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="Q：接口一般规则"><a href="#Q：接口一般规则" class="headerlink" title="Q：接口一般规则"></a>Q：接口一般规则</h4><p><strong>A</strong>：参照：<br><a href="http://nudui.github.io/2015/05/16/api%E6%8E%A5%E5%8F%A3%E8%A7%84%E5%88%99/">http://nudui.github.io/2015/05/16/api%E6%8E%A5%E5%8F%A3%E8%A7%84%E5%88%99/</a></p>
<h4 id="Q：如何保持会话-登录时到底发生了神马"><a href="#Q：如何保持会话-登录时到底发生了神马" class="headerlink" title="Q：如何保持会话,登录时到底发生了神马"></a>Q：如何保持会话,登录时到底发生了神马</h4><p><strong>A</strong>：不建议使用httpsession，如果用httpsession，则须做好session共享策略。我的方案：<a href="http://nudui.github.io/2015/05/16/app%E4%BC%9A%E8%AF%9D%E6%96%B9%E6%A1%88/">http://nudui.github.io/2015/05/16/app%E4%BC%9A%E8%AF%9D%E6%96%B9%E6%A1%88/</a></p>
<p><strong>标注一下</strong>：这个方案不是我原创，是跟一老大哥学的，消化了好一阵时间。（不过，当我消化了这个方案，这应该就算是我的了吧）</p>
<h4 id="Q：如果有人刷我的接口肿么办"><a href="#Q：如果有人刷我的接口肿么办" class="headerlink" title="Q：如果有人刷我的接口肿么办"></a>Q：如果有人刷我的接口肿么办</h4><p><strong>A</strong>：最近我刚刷了一个场子不小的app的短信验证码接口，详情及解决办法请看如下：<a href="http://blog.csdn.net/z744760295/article/details/53345113" target="_blank" rel="external">http://blog.csdn.net/z744760295/article/details/53345113</a></p>
<h4 id="Q：选用云存储还是自存储"><a href="#Q：选用云存储还是自存储" class="headerlink" title="Q：选用云存储还是自存储"></a>Q：选用云存储还是自存储</h4><p><strong>A</strong>：前期建议选用云存储，云存储平台都会有免费额度。七牛云提供10G空间，100万次GET请求；阿里云提供5G，请求次数也不会太低，团队初期足够了。</p>
<h4 id="Q：那如果有一天leader要求存储必须自有化，那已在db中存储的云资源uri怎么办"><a href="#Q：那如果有一天leader要求存储必须自有化，那已在db中存储的云资源uri怎么办" class="headerlink" title="Q：那如果有一天leader要求存储必须自有化，那已在db中存储的云资源uri怎么办"></a>Q：那如果有一天leader要求存储必须自有化，那已在db中存储的云资源uri怎么办</h4><p><strong>A</strong>：使用云存储之前，就必须得考虑好这个问题，七牛和ali都提供自定义域名服务，在自己的域名下做配置，这样图片uri就是通过自有域名进行资源定位。此时，将云中有用的图片下载，根据路径进行文件服务器配置即可。这样，原存储云的文件就可以转入自有服务器，且uri不会改变。</p>
<h4 id="Q：如果我想一直使用云，某天10G空间不够了怎么办"><a href="#Q：如果我想一直使用云，某天10G空间不够了怎么办" class="headerlink" title="Q：如果我想一直使用云，某天10G空间不够了怎么办"></a>Q：如果我想一直使用云，某天10G空间不够了怎么办</h4><p><strong>A</strong>：我这有个投机取巧的办法：如果某天在七牛上的空间已经使用85%，这时就着手再申请一个账号好了，在服务端代码中改一下七牛的配置，切换到第二个账号，这不就ok了吗，原uri不必去管，反正七牛也不会删掉（七牛也不知道这两个账号有啥关联），不过在第二个账号绑定域名时，还是再开一个子域名比较好，不要对第一个账号的资源进行侵扰。</p>
<h4 id="Q：如果某天七牛发现我的小聪明，把我封掉怎么办"><a href="#Q：如果某天七牛发现我的小聪明，把我封掉怎么办" class="headerlink" title="Q：如果某天七牛发现我的小聪明，把我封掉怎么办"></a>Q：如果某天七牛发现我的小聪明，把我封掉怎么办</h4><p><strong>A</strong>：无论是哪个云，在封号前必定多方联络你，这时可把那些云图片资源取出，再放入其他的云，执行同样的策略。</p>
<h4 id="Q：如果其他的云也封怎么办，不能一直这样下去啊"><a href="#Q：如果其他的云也封怎么办，不能一直这样下去啊" class="headerlink" title="Q：如果其他的云也封怎么办，不能一直这样下去啊"></a>Q：如果其他的云也封怎么办，不能一直这样下去啊</h4><p><strong>A</strong>：上述策略，都是为了省！省！省！省，则必定有一些荆棘。不过，就算是这个云把你封掉，也不见得就没办法。【微博】或者其他大sns，它肯定不会删图片，它还开放了各种接口，咱们可以把微博变成我们的图片服务器，这样不就好了吗。微博的水印问题，网上能找到设置方法。<strong>不过，把微博改成自己的文件服务器，是不是挺cool的</strong>。</p>
<h4 id="Q：短信接口都有验证码条数限制，这个也能有对策吧"><a href="#Q：短信接口都有验证码条数限制，这个也能有对策吧" class="headerlink" title="Q：短信接口都有验证码条数限制，这个也能有对策吧"></a>Q：短信接口都有验证码条数限制，这个也能有对策吧</h4><p><strong>A</strong>：没错，这个策略与云存储方案类似。单个短信平台对于验证码会有单独的限制，从3条/h ~ 7条/h 不等，我在做app的时候，也会遇到这个问题，产品要求必须每小时能发8条，打电话给短信客服，确实是可以增加。但是，总觉着不舒服，于是有了以下的方案：在阿里大鱼上申请两个（或多个）账号，短信签名全部一致（不要质疑短信平台是否会允许，亲测有效，反馈给阿里大鱼，人家说没遇到过这种情况，也就默许了）。之后再代码中，只要第一个账号发送失败，就走第二个账号。</p>
<p>当然，如果不嫌麻烦，也可以使用多个不同平台的方式，只是每个平台的接口都不一样。使用单平台多账号，好处是扩展方便，不用改多少代码。</p>
<h4 id="Q：app版本控制怎么玩"><a href="#Q：app版本控制怎么玩" class="headerlink" title="Q：app版本控制怎么玩"></a>Q：app版本控制怎么玩</h4><p><strong>A</strong>：看到网上好多人说单独开一个接口，判断是否需要更新app。这个方案还可以吧，只是需要移动端每次打开app时请求服务端，略有些麻烦。<strong>其实大可不必，服务端完全不需要开辟单独接口</strong>：移动每次与服务端交互，服务端在header中能获取这个请求的具体版本号，缓存必须更新的版本号的value，在拦截器中计算这个版本号的value，看看是否需要强制更新，如果需要，则在拦截器阶段就返回错误码给app，app根据错误码进行提示、下载。<strong><em>这个方案的好处是</em></strong>，无须移动开发人员做太多，覆盖面广，网上的方案只有在特定某个动作触发校验，我的方案是全局校验。</p>
<h4 id="Q：有的app（回家吃饭app），换了个账号登录，竟然收到了原账号的消息，这咋回事"><a href="#Q：有的app（回家吃饭app），换了个账号登录，竟然收到了原账号的消息，这咋回事" class="headerlink" title="Q：有的app（回家吃饭app），换了个账号登录，竟然收到了原账号的消息，这咋回事"></a>Q：有的app（回家吃饭app），换了个账号登录，竟然收到了原账号的消息，这咋回事</h4><p><strong>A</strong>：‘回家吃饭’这个app，业务真的不错，不过它确实有那个问题（八月份的时候）。</p>
<p><strong>先来说说这是怎么发生的：</strong>app登录后，会将devicetoken发送给服务端，服务端将devicetoken与用户id进行绑定（允许一个账号多点登录），这样每次需要push的时候，就可以根据devicetoken进行定向push。那为什么会收到原账号的push呢，因为只  <strong>做了bind，没做unbind</strong> ，‘回家吃饭’没考虑     <strong>app不重新下载而换号登录</strong> 的问题（重新下载app时，devicetoken会发生变化）！</p>
<p><strong>怎么解决：</strong>退出登录时服务端必须<strong>解绑</strong>相应的devicetoken。</p>
<h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>本人水平有限</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;h4 id=&quot;Q：接口一般规则&quot;&gt;&lt;a href=&quot;#Q：接口一般规则&quot; class=&quot;headerlink&quot; title=&quot;Q：接口一般规则&quot;
    
    </summary>
    
      <category term="app-api" scheme="http://nudui.github.io/categories/app-api/"/>
    
    
      <category term="api" scheme="http://nudui.github.io/tags/api/"/>
    
      <category term="app" scheme="http://nudui.github.io/tags/app/"/>
    
      <category term="接口规则" scheme="http://nudui.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>服务端开发-各种小问题</title>
    <link href="http://nudui.github.io/2016/11/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-%E5%90%84%E7%A7%8D%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://nudui.github.io/2016/11/26/服务端开发-各种小问题/</id>
    <published>2016-11-25T17:39:57.000Z</published>
    <updated>2016-11-26T03:29:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="Q：接口一般规则"><a href="#Q：接口一般规则" class="headerlink" title="Q：接口一般规则"></a>Q：接口一般规则</h4><p><strong>A</strong>：参照：<br><a href="http://nudui.github.io/2015/05/16/api%E6%8E%A5%E5%8F%A3%E8%A7%84%E5%88%99/">http://nudui.github.io/2015/05/16/api%E6%8E%A5%E5%8F%A3%E8%A7%84%E5%88%99/</a></p>
<h4 id="Q：如何保持会话-登录时到底发生了神马"><a href="#Q：如何保持会话-登录时到底发生了神马" class="headerlink" title="Q：如何保持会话,登录时到底发生了神马"></a>Q：如何保持会话,登录时到底发生了神马</h4><p><strong>A</strong>：不建议使用httpsession，如果用httpsession，则须做好session共享策略。我的方案：<a href="http://nudui.github.io/2015/05/16/app%E4%BC%9A%E8%AF%9D%E6%96%B9%E6%A1%88/">http://nudui.github.io/2015/05/16/app%E4%BC%9A%E8%AF%9D%E6%96%B9%E6%A1%88/</a></p>
<p><strong>标注一下</strong>：这个方案不是我原创，是跟一老大哥学的，消化了好一阵时间。</p>
<h4 id="Q：如果有人刷我的接口肿么办"><a href="#Q：如果有人刷我的接口肿么办" class="headerlink" title="Q：如果有人刷我的接口肿么办"></a>Q：如果有人刷我的接口肿么办</h4><p><strong>A</strong>：最近我刚刷了一个场子不小的app的短信验证码接口，详情及解决办法请看如下：<a href="http://blog.csdn.net/z744760295/article/details/53345113" target="_blank" rel="external">http://blog.csdn.net/z744760295/article/details/53345113</a></p>
<h4 id="Q：选用云存储还是自存储"><a href="#Q：选用云存储还是自存储" class="headerlink" title="Q：选用云存储还是自存储"></a>Q：选用云存储还是自存储</h4><p><strong>A</strong>：前期建议选用云存储，云存储平台都会有免费额度。七牛云提供10G空间，100万次GET请求；阿里云提供5G，请求次数也不会太低，团队初期足够了。</p>
<h4 id="Q：那如果有一天leader要求存储必须自有化，那已在db中存储的云资源uri怎么办"><a href="#Q：那如果有一天leader要求存储必须自有化，那已在db中存储的云资源uri怎么办" class="headerlink" title="Q：那如果有一天leader要求存储必须自有化，那已在db中存储的云资源uri怎么办"></a>Q：那如果有一天leader要求存储必须自有化，那已在db中存储的云资源uri怎么办</h4><p><strong>A</strong>：使用云存储之前，就必须得考虑好这个问题，七牛和ali都提供自定义域名服务，在自己的域名下做配置，这样图片uri就是通过自有域名进行资源定位。此时，将云中有用的图片下载，根据路径进行文件服务器配置即可。这样，原存储云的文件就可以转入自有服务器，且uri不会改变。</p>
<h4 id="Q：如果我想一直使用云，某天10G空间不够了怎么办"><a href="#Q：如果我想一直使用云，某天10G空间不够了怎么办" class="headerlink" title="Q：如果我想一直使用云，某天10G空间不够了怎么办"></a>Q：如果我想一直使用云，某天10G空间不够了怎么办</h4><p><strong>A</strong>：我这有个投机取巧的办法：如果某天在七牛上的空间已经使用85%，这时就着手再申请一个账号好了，在服务端代码中改一下七牛的配置，切换到第二个账号，这不就ok了吗，原uri不必去管，反正七牛也不会删掉（七牛也不知道这两个账号有啥关联），不过在第二个账号绑定域名时，还是再开一个子域名比较好，不要对第一个账号的资源进行侵扰。</p>
<h4 id="Q：如果某天七牛发现我的小聪明，把我封掉怎么办"><a href="#Q：如果某天七牛发现我的小聪明，把我封掉怎么办" class="headerlink" title="Q：如果某天七牛发现我的小聪明，把我封掉怎么办"></a>Q：如果某天七牛发现我的小聪明，把我封掉怎么办</h4><p><strong>A</strong>：无论是哪个云，在封号前必定多方联络你，这时可把那些云图片资源取出，再放入其他的云，执行同样的策略。</p>
<h4 id="Q：如果其他的云也封怎么办，不能一直这样下去啊"><a href="#Q：如果其他的云也封怎么办，不能一直这样下去啊" class="headerlink" title="Q：如果其他的云也封怎么办，不能一直这样下去啊"></a>Q：如果其他的云也封怎么办，不能一直这样下去啊</h4><p><strong>A</strong>：上述策略，都是为了省！省！省！省，则必定有一些荆棘。不过，就算是这个云把你封掉，也不见得就没办法。【微博】或者其他大sns，它肯定不会删图片，它还开放了各种接口，咱们可以把微博变成我们的图片服务器，这样不就好了吗。微博的水印问题，网上能找到设置方法。<strong>不过，把微博改成自己的文件服务器，是不是挺cool的</strong>。</p>
<h4 id="Q：短信接口都有验证码条数限制，这个也能有对策吧"><a href="#Q：短信接口都有验证码条数限制，这个也能有对策吧" class="headerlink" title="Q：短信接口都有验证码条数限制，这个也能有对策吧"></a>Q：短信接口都有验证码条数限制，这个也能有对策吧</h4><p><strong>A</strong>：没错，这个策略与云存储方案类似。单个短信平台对于验证码会有单独的限制，从3条/h ~ 7条/h 不等，我在做app的时候，也会遇到这个问题，产品要求必须每小时能发8条，打电话给短信客服，确实是可以增加。但是，总觉着不舒服，于是有了以下的方案：在阿里大鱼上申请两个（或多个）账号，短信签名全部一致（不要质疑短信平台是否会允许，亲测有效，反馈给阿里大鱼，人家说没遇到过这种情况，也就默许了）。之后再代码中，只要第一个账号发送失败，就走第二个账号。</p>
<p>当然，如果不嫌麻烦，也可以使用多个不同平台的方式，只是每个平台的接口都不一样。使用单平台多账号，好处是扩展方便，不用改多少代码。</p>
<h4 id="Q：app版本控制怎么玩"><a href="#Q：app版本控制怎么玩" class="headerlink" title="Q：app版本控制怎么玩"></a>Q：app版本控制怎么玩</h4><p><strong>A</strong>：看到网上好多人说单独开一个接口，判断是否需要更新app。这个方案还可以吧，只是需要移动端每次打开app时请求服务端，略有些麻烦。<strong>其实大可不必，服务端完全不需要开辟单独接口</strong>：移动每次与服务端交互，服务端在header中能获取这个请求的具体版本号，缓存必须更新的版本号的value，在拦截器中计算这个版本号的value，看看是否需要强制更新，如果需要，则在拦截器阶段就返回错误码给app，app根据错误码进行提示、下载。<strong><em>这个方案的好处是</em></strong>，无须移动开发人员做太多，覆盖面广，网上的方案只有在特定某个动作触发校验，我的方案是全局校验。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;h4 id=&quot;Q：接口一般规则&quot;&gt;&lt;a href=&quot;#Q：接口一般规则&quot; class=&quot;headerlink&quot; title=&quot;Q：接口一般规则&quot;
    
    </summary>
    
      <category term="app-api" scheme="http://nudui.github.io/categories/app-api/"/>
    
    
      <category term="api" scheme="http://nudui.github.io/tags/api/"/>
    
      <category term="app" scheme="http://nudui.github.io/tags/app/"/>
    
      <category term="接口规则" scheme="http://nudui.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>刷某体育票务app短信验证码接口-接口安全考究</title>
    <link href="http://nudui.github.io/2016/11/25/%E5%88%B7app%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3-%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E8%80%83%E7%A9%B6/"/>
    <id>http://nudui.github.io/2016/11/25/刷app短信接口-接口安全考究/</id>
    <published>2016-11-25T15:03:43.000Z</published>
    <updated>2016-11-25T16:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="观察某体育票务app的接口结构"><a href="#观察某体育票务app的接口结构" class="headerlink" title="观察某体育票务app的接口结构"></a>观察某体育票务app的接口结构</h3><p>此app内有某语言大神，余心诚向往，隐去app名讳。<br>短信接口如下：</p>
<p><img src="http://7q5c85.com1.z0.glb.clouddn.com/api3333.png" alt="短信验证码"><br>圈1：</p>
<ul>
<li>参数s：应该是对url进行签名</li>
<li>参数t：时间戳</li>
<li>参数mobile：接收短信验证码的手机</li>
<li>http/1.1 : http协议</li>
</ul>
<p>圈2：</p>
<ul>
<li>cookie：该团队应该是原做web，习惯于cookie、session的模式（当然，这个路子是正确的，只是这个名字…暴露了自己的历史包袱）。在app中通过在header中添加参数来实现。此处与本题无关。</li>
</ul>
<p>圈3：</p>
<ul>
<li>ChannelId：一个对于业务相关的参数，无甚可说。</li>
<li>token：应该是对设备的唯一标识吧。应该不是auth，毕竟还没登录，何来auth。</li>
</ul>
<p>从上可知，模拟这个【发送短信验证码】请求，最多需要这么几个参数即可。笔者用postman实践，cookie可以不用管它（话说，这个cookie真的有价值吗？），传不传都无所谓。参数t，对方只用于签名算法。</p>
<p>综上，需要参数s、t、参数mobile、参数Channel（放在header中）、参数token（放在header中）。</p>
<h3 id="模拟开始"><a href="#模拟开始" class="headerlink" title="模拟开始"></a>模拟开始</h3><p><strong>某月24日：</strong></p>
<p><img src="http://7q5c85.com1.z0.glb.clouddn.com/%E6%A8%A1%E6%8B%9Fapi.png" alt="image description"></p>
<p>诸位应当看到，笔者已经告知对方（通过一个多余的参数“tip”），该接口（或者整个app的所有接口），都有可能被模拟，希望对方能够进行修改。<strong>注：</strong>笔者手机号也在区间内，收到了通过程序发送的短信验证码。</p>
<p><strong>次日：</strong></p>
<p><img src="http://7q5c85.com1.z0.glb.clouddn.com/ciri.png" alt="image description"></p>
<p>对方完全任由刷。</p>
<h3 id="模拟后话"><a href="#模拟后话" class="headerlink" title="模拟后话"></a>模拟后话</h3><ol>
<li>次日的再次模拟，依然请求成功（笔者的手机号在此序列）。</li>
<li>对方将笔者ip做了特殊处理（此项排除，笔者手机收到了验证码）。</li>
<li>对方没有看到相应日志，没有发现接口已经被模拟。（不太可能，毕竟不是小team，就算是小team，也早该发现）</li>
<li>对方没有看到tip参数，没有在日志中记录收到的全部参数。（感觉还是不可能，都不是小作坊，我这一个岗位一个人的小摊子还会注意到这点。。）</li>
<li>原因究竟是什么呢？</li>
</ol>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><ol>
<li>笔者毕业三年，路已偏歪，没在大型厂子待过。</li>
<li>可能笔者的整篇文章会见笑于大方家（大神甲：这年轻人太嫩，自以为破解了这个app，其实。。）</li>
<li>不是hacker（水平真的达不到，差的不是一点），却心向往之。</li>
<li>个人对于接口安全的方案（方案师承毕业时的团队）<a href="http://nudui.online/2015/05/16/api接口规则/" target="_blank" rel="external">http://nudui.online/2015/05/16/api接口规则/</a>。</li>
<li>求明白人告诉我，我这到底是不是班门弄斧。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;观察某体育票务app的接口结构&quot;&gt;&lt;a href=&quot;#观察某体育票务app的接口结构&quot; class=&quot;headerlink&quot; title=&quot;观察某体育票务app的接口结构&quot;&gt;&lt;/a&gt;观察某体育票务app的接口结构&lt;/h3&gt;&lt;p&gt;此app内有某语言大神，余心诚向往，
    
    </summary>
    
      <category term="app-api" scheme="http://nudui.github.io/categories/app-api/"/>
    
    
      <category term="api" scheme="http://nudui.github.io/tags/api/"/>
    
      <category term="app" scheme="http://nudui.github.io/tags/app/"/>
    
      <category term="接口规则" scheme="http://nudui.github.io/tags/%E6%8E%A5%E5%8F%A3%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>算法夕拾（09）--冒泡</title>
    <link href="http://nudui.github.io/2016/11/22/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE%EF%BC%8809%EF%BC%89-%E5%86%92%E6%B3%A1/"/>
    <id>http://nudui.github.io/2016/11/22/算法夕拾（09）-冒泡/</id>
    <published>2016-11-21T19:04:30.000Z</published>
    <updated>2016-11-21T19:52:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>两两比对，调整顺序，比较n-1次</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void sort(int[] arr) &#123;</div><div class="line">	for (int i = 1; i &lt; arr.length; i++) &#123;</div><div class="line">		for (int j = 0; j &lt; arr.length - i; j++) &#123;</div><div class="line">			if (arr[j] &lt; arr[j + 1]) &#123;</div><div class="line">				int tmp = arr[j];</div><div class="line">				arr[j] = arr[j + 1];</div><div class="line">				arr[j + 1] = tmp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for (int i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">		System.out.println(arr[i]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间：O(n2)</p>
<p>空间：O(1)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;两两比对，调整顺序，比较n-1次&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="算法夕拾" scheme="http://nudui.github.io/categories/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="算法" scheme="http://nudui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法夕拾（08）--桶排序</title>
    <link href="http://nudui.github.io/2016/11/22/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE%EF%BC%8808%EF%BC%89-%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://nudui.github.io/2016/11/22/算法夕拾（08）-桶排序/</id>
    <published>2016-11-21T18:42:11.000Z</published>
    <updated>2016-11-21T19:03:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li>事先准备N个桶，每个桶代表从1到N的值。</li>
<li>将N-1个待排序数字，按照N桶的数字进行放入。</li>
<li>相同的桶放入了n次相同数字，则相应的桶的值为n。</li>
<li>遍历N个桶，只要桶中的值大于0，则输出序号，值为2，则输出两次该序号。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  桶排序</div><div class="line"> */</div><div class="line">public static void sort(int[] array, int range) &#123;</div><div class="line">    </div><div class="line">    // 桶</div><div class="line">    int[] bucket = new int[range];</div><div class="line"></div><div class="line">    // 遍历array，向bucket中表示</div><div class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</div><div class="line">        int index = array[i];</div><div class="line">        bucket[index] = bucket[index] + 1;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 输出</div><div class="line">    for (int i = 0; i &lt; bucket.length; i++) &#123;</div><div class="line">        for (int j = 0; j &lt; bucket[i]; j++) &#123;</div><div class="line">            System.out.println(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>桶排序实际上只需要遍历一遍所有的元素，然后依次放入制定的位置。如果加上输出排序的时间，那么时间复杂度为O(n+m)，n：待排序的元素个数，m：桶的个数。很快，但是空间消耗比较大。</p>
<p>元素跨度越大，空间消耗越大，空间利用率越低，浪费越大。</p>
<p>但是  <strong><em>快</em></strong>  ！</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>数据分布相对均匀，跨度不太大的场景。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>利用类似散列表的方式，改善空间利用率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;事先准备N个桶，每个桶代表从1到N的值。&lt;/li&gt;
&lt;li&gt;将N-1个待排序数字，按照N桶的数字进行放入。&lt;/li&gt;
&lt;li&gt;相
    
    </summary>
    
      <category term="算法夕拾" scheme="http://nudui.github.io/categories/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="算法" scheme="http://nudui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>beego(01)</title>
    <link href="http://nudui.github.io/2016/11/21/beego-01/"/>
    <id>http://nudui.github.io/2016/11/21/beego-01/</id>
    <published>2016-11-21T08:52:21.000Z</published>
    <updated>2016-11-21T10:57:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>get beego : <a href="https://my.oschina.net/ichendong/blog/761467" target="_blank" rel="external">https://my.oschina.net/ichendong/blog/761467</a></p>
<p>gov docs : <a href="https://beego.me" target="_blank" rel="external">https://beego.me</a></p>
<h3 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h3><p>mac环境下快速启动工作目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rm /usr/local/bin/subl</div><div class="line"></div><div class="line">ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/subl</div></pre></td></tr></table></figure>
<p>在 ~/ 目录下创建.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim work_hello.sh</div></pre></td></tr></table></figure>
<p>work_hello.sh ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">subl /Users/jack/gopath/src/hello</div></pre></td></tr></table></figure></p>
<p>对该sh赋予执行权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 777 work_hello.sh</div></pre></td></tr></table></figure>
<p>开始工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd</div><div class="line">./work_hello.sh</div></pre></td></tr></table></figure>
<p>自动在sublime中打开工作空间。如有多个工作空间，则在~/目录下创建多个sh即可</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;start&quot;&gt;&lt;a href=&quot;#start&quot; class=&quot;headerlink&quot; title=&quot;start&quot;&gt;&lt;/a&gt;start&lt;/h3&gt;&lt;p&gt;get beego : &lt;a href=&quot;https://my.oschina.net/ichendong/blog
    
    </summary>
    
      <category term="beego" scheme="http://nudui.github.io/categories/beego/"/>
    
    
      <category term="beego" scheme="http://nudui.github.io/tags/beego/"/>
    
  </entry>
  
  <entry>
    <title>mac安装beego</title>
    <link href="http://nudui.github.io/2016/11/21/mac%E5%AE%89%E8%A3%85beego/"/>
    <id>http://nudui.github.io/2016/11/21/mac安装beego/</id>
    <published>2016-11-20T21:56:20.000Z</published>
    <updated>2016-11-20T22:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="由于按照谢孟军git上的说明，安装出现各种错误："><a href="#由于按照谢孟军git上的说明，安装出现各种错误：" class="headerlink" title="由于按照谢孟军git上的说明，安装出现各种错误："></a>由于按照谢孟军git上的说明，安装出现各种错误：</h4><ul>
<li>cannot download, $GOPATH not set. For more details see: go help gopath</li>
<li>liteide GolangFmt: Could not find go env</li>
<li>其他导致ide出现问题的错误</li>
</ul>
<p>几经周折，安装如下：<br><a href="https://my.oschina.net/ichendong/blog/761467" target="_blank" rel="external">https://my.oschina.net/ichendong/blog/761467</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;由于按照谢孟军git上的说明，安装出现各种错误：&quot;&gt;&lt;a href=&quot;#由于按照谢孟军git上的说明，安装出现各种错误：&quot; class=&quot;headerlink&quot; title=&quot;由于按照谢孟军git上的说明，安装出现各种错误：&quot;&gt;&lt;/a&gt;由于按照谢孟军git上的说明
    
    </summary>
    
      <category term="golang" scheme="http://nudui.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://nudui.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>算法夕拾（07）--链表</title>
    <link href="http://nudui.github.io/2016/11/19/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE%EF%BC%8807%EF%BC%89-%E9%93%BE%E8%A1%A8/"/>
    <id>http://nudui.github.io/2016/11/19/算法夕拾（07）-链表/</id>
    <published>2016-11-19T06:31:22.000Z</published>
    <updated>2016-11-19T06:57:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何谓链表"><a href="#何谓链表" class="headerlink" title="何谓链表"></a>何谓链表</h3><ul>
<li>在物理存储上非连续、非顺序的存储结构。</li>
<li>数据之间通过指针关联。</li>
<li>data（数据）、next（指针）</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>物理空间不连续，内存开销较大（存储指针）。</li>
<li>无容量限制。</li>
<li>查找元素需要顺序遍历。</li>
<li>操作复杂。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div></pre></td><td class="code"><pre><div class="line">package linkedlist;</div><div class="line"></div><div class="line">/**</div><div class="line"> *	链表实现</div><div class="line"> */</div><div class="line">public class LinkedList &#123;</div><div class="line"></div><div class="line">	public Node head = null; // 头节点</div><div class="line">	public Node tail = null; // 尾节点</div><div class="line"></div><div class="line">	public int size = 0;</div><div class="line"></div><div class="line">	// 头插入</div><div class="line">	public boolean insertHead(Object data) &#123;</div><div class="line">		if (size == 0) &#123;</div><div class="line">			initial(data);</div><div class="line">		&#125; else &#123;</div><div class="line">			Node node = new Node(data);</div><div class="line">			node.setNext(head);</div><div class="line">			head = node;</div><div class="line">		&#125;</div><div class="line">		size++;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 尾插入</div><div class="line">	public boolean insertTail(Object data) &#123;</div><div class="line">		if (size == 0) &#123;</div><div class="line">			initial(data);</div><div class="line">		&#125; else &#123;</div><div class="line">			Node node = new Node(data);</div><div class="line">			tail.setNext(node);</div><div class="line">			tail = node;</div><div class="line">		&#125;</div><div class="line">		size++;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 中间插入,插入到index的后面</div><div class="line">	public boolean insertAfter(int index, Object data) throws Exception &#123;</div><div class="line">		if (index &gt; size) &#123;</div><div class="line">			insertTail(data);</div><div class="line">		&#125; else &#123;</div><div class="line">			if (index == 0) &#123;</div><div class="line">				insertHead(data);</div><div class="line">			&#125; else &#123;</div><div class="line">				// 获得index对应的node</div><div class="line">				Node indexNode = getByIndex(index);</div><div class="line">				Node node = new Node(data);</div><div class="line">				node.setNext(indexNode.getNext());</div><div class="line">				indexNode.setNext(node);</div><div class="line">				size++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 头删除</div><div class="line">	public boolean removeHead() throws Exception &#123;</div><div class="line">		if (size == 0) &#123;</div><div class="line">			throw new Exception(&quot;likedlist is empty , can not remove head node&quot;);</div><div class="line">		&#125;</div><div class="line">		head.setData(head.getNext().getData());</div><div class="line">		head.setNext(head.getNext().getNext());</div><div class="line">		size--;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 尾删除</div><div class="line">	public boolean removeTail() throws Exception &#123;</div><div class="line">		if (size == 0) &#123;</div><div class="line">			throw new Exception(&quot;likedlist is empty , can not remove tail node&quot;);</div><div class="line">		&#125;</div><div class="line">		size--;</div><div class="line">		Node newTail = getByIndex(size);</div><div class="line">		newTail.setNext(null);</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 中间删除</div><div class="line">	public boolean removeIndex(int index) throws Exception &#123;</div><div class="line">		if (size == 0) &#123;</div><div class="line">			throw new Exception(&quot;likedlist is empty , can not remove any node&quot;);</div><div class="line">		&#125;</div><div class="line">		Node indexNode = getByIndex(index);</div><div class="line">		indexNode.setData(indexNode.getNext().getData());</div><div class="line">		indexNode.setNext(indexNode.getNext().getNext());</div><div class="line">		size--;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 查找</div><div class="line">	public Node getByIndex(int index) throws Exception &#123;</div><div class="line">		if (index &gt; size) &#123;</div><div class="line">			throw new Exception(&quot;list is out by index &quot; + index);</div><div class="line">		&#125;</div><div class="line">		Node result = head;</div><div class="line">		for (int i = 2; i &lt;= index; i++) &#123;</div><div class="line">			result = result.getNext();</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 初始化第一个元素</div><div class="line">	public void initial(Object data) &#123;</div><div class="line">		Node n = new Node(data);</div><div class="line">		head = n;</div><div class="line">		tail = n;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    //遍历</div><div class="line">	public void traverse() &#123;</div><div class="line">		Node tmp = head;</div><div class="line">		while (tmp != null) &#123;</div><div class="line">			System.out.println(tmp.getData());</div><div class="line">			tmp = tmp.getNext();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	// 反转</div><div class="line">	public void reverse() &#123;</div><div class="line">		Node tmp = head;</div><div class="line">		Node tmp1 = tmp.getNext();</div><div class="line">		for (int i = 0; i &lt; size - 1; i++) &#123;</div><div class="line">			Node tmp2 = tmp1.getNext();</div><div class="line">			tmp1.setNext(tmp);</div><div class="line">			tmp = tmp1;</div><div class="line">			tmp1 = tmp2;</div><div class="line">		&#125;</div><div class="line">		head.setNext(null);</div><div class="line">		head = tmp;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 节点</div><div class="line">class Node &#123;</div><div class="line"></div><div class="line">	private Object data;</div><div class="line">	private Node next;</div><div class="line"></div><div class="line">	public Node() &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Node(Object data) &#123;</div><div class="line">		super();</div><div class="line">		this.data = data;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object getData() &#123;</div><div class="line">		return data;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setData(Object data) &#123;</div><div class="line">		this.data = data;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Node getNext() &#123;</div><div class="line">		return next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setNext(Node next) &#123;</div><div class="line">		this.next = next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;何谓链表&quot;&gt;&lt;a href=&quot;#何谓链表&quot; class=&quot;headerlink&quot; title=&quot;何谓链表&quot;&gt;&lt;/a&gt;何谓链表&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在物理存储上非连续、非顺序的存储结构。&lt;/li&gt;
&lt;li&gt;数据之间通过指针关联。&lt;/li&gt;
&lt;li&gt;data（数
    
    </summary>
    
      <category term="算法夕拾" scheme="http://nudui.github.io/categories/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="算法" scheme="http://nudui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法夕拾（06）--用队列实现栈</title>
    <link href="http://nudui.github.io/2016/11/19/%E6%8A%84%E4%B9%A6%E5%AD%A6%E7%AE%97%E6%B3%95%EF%BC%8806%EF%BC%89-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>http://nudui.github.io/2016/11/19/抄书学算法（06）-用队列实现栈/</id>
    <published>2016-11-18T18:36:05.000Z</published>
    <updated>2016-11-18T19:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ol>
<li>声明两个队列</li>
<li>入栈：向非空队列中put元素，如都为空，则随便选。</li>
<li>出栈：将非空中的lenth-1个元素put到另外一个队列中，出队最后一个元素。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">package queue2stack;</div><div class="line"></div><div class="line">import Queue.Queue;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 队列实现栈，可扩容</div><div class="line"> * </div><div class="line"> * @author jack</div><div class="line"> * 2016年11月19日 上午2:52:04</div><div class="line"> */</div><div class="line">public class Stack &#123;</div><div class="line"></div><div class="line">	private Queue q1;</div><div class="line">	private Queue q2;</div><div class="line"></div><div class="line">	private int cap = 10;</div><div class="line"></div><div class="line">	public Stack(int cap) &#123;</div><div class="line">		super();</div><div class="line">		this.cap = cap;</div><div class="line">		this.q1 = new Queue(cap + 1);</div><div class="line">		this.q2 = new Queue(cap + 1);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 入栈</div><div class="line">	public boolean push(Object o) throws Exception &#123;</div><div class="line">		Queue q;</div><div class="line">		if (q1.isEmpty()) &#123;</div><div class="line">			q = q1;</div><div class="line">		&#125;</div><div class="line">		q = q2;</div><div class="line">		if (q.isFull()) &#123;</div><div class="line">			expand();</div><div class="line">		&#125;</div><div class="line">		q = q2;</div><div class="line">		return q.put(o);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 出栈</div><div class="line">	public Object pop() throws Exception &#123;</div><div class="line">		Queue from;</div><div class="line">		Queue to;</div><div class="line">		if (!q1.isEmpty()) &#123;</div><div class="line">			from = q1;</div><div class="line">			to = q2;</div><div class="line">		&#125; else &#123;</div><div class="line">			from = q2;</div><div class="line">			to = q1;</div><div class="line">		&#125;</div><div class="line">		queueTransExceptOne(from, to);</div><div class="line">		return from.poll();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 扩容</div><div class="line">	private void expand() throws Exception &#123;</div><div class="line">		this.cap = this.cap * 2 + 1;</div><div class="line">		Queue q3 = new Queue(this.cap);</div><div class="line">		Queue q4 = new Queue(this.cap);</div><div class="line">		queueTrans(q1, q3);</div><div class="line">		queueTrans(q2, q4);</div><div class="line">		q1 = q3;</div><div class="line">		q2 = q4;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void queueTransExceptOne(Queue queue1, Queue queue2) throws Exception &#123;</div><div class="line">		while (queue1.getSize() &gt; 1) &#123;</div><div class="line">			queue2.put(queue1.poll());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void queueTrans(Queue queue1, Queue queue2) throws Exception &#123;</div><div class="line">		while (!queue1.isEmpty()) &#123;</div><div class="line">			queue2.put(queue1.poll());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">package queue2stack;</div><div class="line"></div><div class="line">import queue2stack.Stack;</div><div class="line"></div><div class="line">/**</div><div class="line"> *</div><div class="line"> * @author jack</div><div class="line"> * 2016年11月19日 上午3:03:57</div><div class="line"> */</div><div class="line">public class Test &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Stack stack = new Stack(5);</div><div class="line"></div><div class="line">		for (int i = 0; i &lt; 15; i++) &#123;</div><div class="line">			try &#123;</div><div class="line">				stack.push(i + &quot;&quot;);</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		for (int i = 0; i &lt; 15; i++) &#123;</div><div class="line">			try &#123;</div><div class="line">				System.out.println(stack.pop());</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		try &#123;</div><div class="line">			System.out.println(stack.pop());</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">//		System.out.println(stack.s);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;方案&quot;&gt;&lt;a href=&quot;#方案&quot; class=&quot;headerlink&quot; title=&quot;方案&quot;&gt;&lt;/a&gt;方案&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;声明两个队列&lt;/li&gt;
&lt;li&gt;入栈：向非空队列中put元素，如都为空，则随便选。&lt;/li&gt;
&lt;li&gt;出栈：将非空中的lenth
    
    </summary>
    
      <category term="算法夕拾" scheme="http://nudui.github.io/categories/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="算法" scheme="http://nudui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法夕拾（05）--用栈实现队列</title>
    <link href="http://nudui.github.io/2016/11/19/%E6%8A%84%E4%B9%A6%E5%AD%A6%E7%AE%97%E6%B3%95%EF%BC%8805%EF%BC%89-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://nudui.github.io/2016/11/19/抄书学算法（05）-用栈实现队列/</id>
    <published>2016-11-18T18:05:41.000Z</published>
    <updated>2016-11-18T19:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><h4 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h4><p>此方案较为繁琐。</p>
<ol>
<li>声明两个栈A,B。</li>
<li>队列put：将A中的所有元素压入B中，向A中压入元素，将B中所有元素压回。</li>
<li>队列poll：将A中元素全部压入B，B出栈。</li>
</ol>
<h4 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h4><ol>
<li>申明两个栈A,B。A专职入队，B专职出队。</li>
<li>队列put：向A中压入元素。</li>
<li>队列poll：如B中有，则B出栈。如果B为空，则将A中元素全部压入B，然后B中出栈。</li>
</ol>
<h3 id="实现（方案2）"><a href="#实现（方案2）" class="headerlink" title="实现（方案2）"></a>实现（方案2）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">package stack2queue;</div><div class="line"></div><div class="line">import stack.Stack;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author jack</div><div class="line"> * 2016年11月19日 上午2:20:25</div><div class="line"> */</div><div class="line">public class Queue &#123;</div><div class="line"></div><div class="line">	private Stack s1; // 专门入栈</div><div class="line">	private Stack s2; // 专门出栈</div><div class="line"></div><div class="line">	public Queue(int cap) &#123;</div><div class="line">		super();</div><div class="line">		this.s1 = new Stack(cap);</div><div class="line">		this.s2 = new Stack(cap);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 入队</div><div class="line">	public boolean put(Object o) &#123;</div><div class="line">		return s1.push(o);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 出队</div><div class="line">	public Object poll() throws Exception &#123;</div><div class="line">		if (s2.isEmpty()) &#123;</div><div class="line">			stackTrans(s1, s2);</div><div class="line">		&#125;</div><div class="line">		return s2.pop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 栈之间全拷贝</div><div class="line">	private void stackTrans(Stack stack1, Stack stack2) throws Exception &#123;</div><div class="line">		while (!stack1.isEmpty()) &#123;</div><div class="line">			Object o = stack1.pop();</div><div class="line">			stack2.push(o);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用栈实现队列&quot;&gt;&lt;a href=&quot;#用栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;用栈实现队列&quot;&gt;&lt;/a&gt;用栈实现队列&lt;/h3&gt;&lt;h4 id=&quot;方案1&quot;&gt;&lt;a href=&quot;#方案1&quot; class=&quot;headerlink&quot; title=&quot;方案1
    
    </summary>
    
      <category term="算法夕拾" scheme="http://nudui.github.io/categories/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="算法" scheme="http://nudui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法夕拾（04）--队列</title>
    <link href="http://nudui.github.io/2016/11/19/%E6%8A%84%E4%B9%A6%E5%AD%A6%E7%AE%97%E6%B3%95%EF%BC%8804%EF%BC%89-%E9%98%9F%E5%88%97/"/>
    <id>http://nudui.github.io/2016/11/19/抄书学算法（04）-队列/</id>
    <published>2016-11-18T17:29:15.000Z</published>
    <updated>2016-11-18T19:40:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列特点"><a href="#队列特点" class="headerlink" title="队列特点"></a>队列特点</h3><ul>
<li>一段连续的内存空间（存疑）</li>
<li>先进先出</li>
<li>put（入队）、poll（出队）</li>
<li>可由数组、链表实现</li>
<li>顺序队列、循环队列</li>
<li>head(头) , tail(尾)</li>
</ul>
<p>顺序队列会造成“假上溢”（head已经poll之后，再put时却无法使用原head位置的内存），于是应使用循环队列 </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">package Queue;</div><div class="line"></div><div class="line">/**</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author jack</div><div class="line"> * 2016年11月19日 上午1:37:17</div><div class="line"> */</div><div class="line">public class Queue &#123;</div><div class="line">	//  h       t</div><div class="line">	// [0,1,2,3,4]</div><div class="line">	private Object[] arr;</div><div class="line">	int head = 0;</div><div class="line">	int tail = 0; // tail处不存储元素</div><div class="line"></div><div class="line">	public Queue(int cap) &#123;</div><div class="line">		arr = new Object[cap];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 入队</div><div class="line">	public boolean put(Object object) throws Exception &#123;</div><div class="line">		if (isFull()) &#123;</div><div class="line">			throw new Exception(&quot;The queue is full now&quot;);</div><div class="line">		&#125;</div><div class="line">		arr[tail] = object;</div><div class="line">		tail = (tail + 1) % arr.length;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 出队</div><div class="line">	public Object poll() throws Exception &#123;</div><div class="line">		if (isEmpty()) &#123;</div><div class="line">			throw new Exception(&quot;The queue is empty now&quot;);</div><div class="line">		&#125;</div><div class="line">		Object result = arr[head];</div><div class="line">		head = (head + 1) % arr.length;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 判断是否满</div><div class="line">	public boolean isFull() &#123;</div><div class="line">		return head == (tail + 1) % arr.length;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 判断是否空</div><div class="line">	public boolean isEmpty() &#123;</div><div class="line">		return head == tail;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 获得队顶元素</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;队列特点&quot;&gt;&lt;a href=&quot;#队列特点&quot; class=&quot;headerlink&quot; title=&quot;队列特点&quot;&gt;&lt;/a&gt;队列特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一段连续的内存空间（存疑）&lt;/li&gt;
&lt;li&gt;先进先出&lt;/li&gt;
&lt;li&gt;put（入队）、poll（出队）&lt;/l
    
    </summary>
    
      <category term="算法夕拾" scheme="http://nudui.github.io/categories/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="存疑" scheme="http://nudui.github.io/tags/%E5%AD%98%E7%96%91/"/>
    
      <category term="算法" scheme="http://nudui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>golang笔记-5-数据</title>
    <link href="http://nudui.github.io/2016/11/18/golang%E7%AC%94%E8%AE%B0-5-%E6%95%B0%E6%8D%AE/"/>
    <id>http://nudui.github.io/2016/11/18/golang笔记-5-数据/</id>
    <published>2016-11-18T02:22:41.000Z</published>
    <updated>2016-11-18T03:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串为不可变字节（byte）序列，是符合结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type stringStruct struct&#123;</div><div class="line">    str unsafe.Pointer</div><div class="line">    len int</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>头部指针指向数组，无NULL结尾，默认为UTF-8存储Unicode字符。</p>
<p>len返回的是数组的字节长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func main()&#123;</div><div class="line">    s := &quot;a&quot;</div><div class="line">    fmt.Println(s[0])   //  97</div><div class="line">    </div><div class="line">    fmt.Println(&amp;s[0])   //  报错：cannot take the address of s[0]</div><div class="line">    </div><div class="line">    s = s + &quot;b&quot;</div><div class="line">    fmt.Println(s &gt; &quot;aa&quot;)   //true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字符串遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func main()&#123;</div><div class="line">    s := &quot;受命于天&quot;</div><div class="line">    for i := 0; i &lt; len(s); i++ &#123;</div><div class="line">        fmt.Println(s[i])       //输出其byte ， 4 * 3 = 12 个字节</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for index, val := range s &#123;</div><div class="line">        fmt.Println(index, val)        //输出每个汉字</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改字符串<br>要求改字符串，须将其转换为可变类型（[ ]rune 或者 [ ]byte），修改之后再转回来。但，不管如何转换，都必定重新分配内存并复制数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h3&gt;&lt;p&gt;字符串为不可变字节（byte）序列，是符合结构。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
    
    </summary>
    
      <category term="golang" scheme="http://nudui.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://nudui.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>算法夕拾（03）--栈</title>
    <link href="http://nudui.github.io/2016/11/18/%E6%8A%84%E4%B9%A6%E5%AD%A6%E7%AE%97%E6%B3%95%EF%BC%8803%EF%BC%89-%E6%A0%88/"/>
    <id>http://nudui.github.io/2016/11/18/抄书学算法（03）-栈/</id>
    <published>2016-11-17T16:50:26.000Z</published>
    <updated>2016-11-18T19:40:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><ul>
<li>一段连续的内存空间</li>
<li>先进后出</li>
<li>push（进栈）、pop（出栈）</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">package stack;</div><div class="line"></div><div class="line">import java.util.Arrays;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 栈的定义</div><div class="line"> *</div><div class="line"> * @author jack</div><div class="line"> * 2016-11-18 上午12:56:22</div><div class="line"> */</div><div class="line">public class Stack &#123;</div><div class="line">	</div><div class="line">	private int cap = 10;   // 数组长度</div><div class="line">	</div><div class="line">	private int size = 0;   // 已经使用长度</div><div class="line"></div><div class="line">	private Object[] arr;	// 存储</div><div class="line"></div><div class="line">	// 构造器</div><div class="line">	public Stack(int cap) &#123;</div><div class="line">		super();</div><div class="line">		this.cap = cap;</div><div class="line">		arr = new Object[cap];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 入栈，考虑扩容</div><div class="line">	public boolean push(Object object) &#123;</div><div class="line">		// 扩容</div><div class="line">		if (isFull()) &#123;</div><div class="line">			expand();</div><div class="line">		&#125;</div><div class="line">		//添加元素</div><div class="line">		arr[size ++] = object;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	// 出栈</div><div class="line">	public Object pop() throws Exception&#123;</div><div class="line">		if(isEmpty())&#123;</div><div class="line">			throw new Exception(&quot;No ele in this stack&quot;);</div><div class="line">		&#125;</div><div class="line">		Object result = getTop();</div><div class="line">		size-- ;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	// 栈顶元素</div><div class="line">	public Object getTop()&#123;</div><div class="line">		return arr[size - 1];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	// 判断是否满</div><div class="line">	public boolean isFull() &#123;</div><div class="line">		return size == cap;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 判断是否空</div><div class="line">	public boolean isEmpty() &#123;</div><div class="line">		return size == 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    // 扩容</div><div class="line">	private void expand() &#123;</div><div class="line">		cap = cap * 2;</div><div class="line">		arr = Arrays.copyOf(arr, cap);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package stack;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author jack</div><div class="line"> * 2016-11-18 上午1:08:53</div><div class="line"> */</div><div class="line">public class Test &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Stack stack = new Stack(5);</div><div class="line">		</div><div class="line">		for (int i = 0; i &lt; 15; i++) &#123;</div><div class="line">			stack.push(i + &quot;&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		for (int i = 0; i &lt; 15; i++) &#123;</div><div class="line">			try &#123;</div><div class="line">				System.out.println(stack.pop());</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		try &#123;</div><div class="line">			System.out.println(stack.pop());</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>逆序输出。</li>
<li>语法检查：凡是遇到“（”则入栈，只要遇到“）”就对比栈顶元素是否与之对应。</li>
<li>数制转换。</li>
</ul>
<p>数制转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">题目：十进制100转换为8进制</div><div class="line">解法：  将 100 ➗ 8 = 12 余 4，将4压入栈。</div><div class="line">        将 12 ➗ 8  = 1 余 4 ,  将4压入栈 。</div><div class="line">        1 压入栈</div><div class="line">        出栈：144</div><div class="line">结果：  144</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;栈的特点&quot;&gt;&lt;a href=&quot;#栈的特点&quot; class=&quot;headerlink&quot; title=&quot;栈的特点&quot;&gt;&lt;/a&gt;栈的特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一段连续的内存空间&lt;/li&gt;
&lt;li&gt;先进后出&lt;/li&gt;
&lt;li&gt;push（进栈）、pop（出栈）&lt;/li&gt;
&lt;
    
    </summary>
    
      <category term="算法夕拾" scheme="http://nudui.github.io/categories/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="算法" scheme="http://nudui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法夕拾（02）--集合、散列表</title>
    <link href="http://nudui.github.io/2016/11/17/%E6%8A%84%E4%B9%A6%E5%AD%A6%E7%AE%97%E6%B3%95%EF%BC%8802%EF%BC%89-%E9%9B%86%E5%90%88/"/>
    <id>http://nudui.github.io/2016/11/17/抄书学算法（02）-集合/</id>
    <published>2016-11-17T15:56:30.000Z</published>
    <updated>2016-11-18T19:40:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何谓集合"><a href="#何谓集合" class="headerlink" title="何谓集合"></a>何谓集合</h3><ul>
<li>基于数组的拓展，无长度限制。</li>
<li><strong>列表</strong>：有序集合。链表、队列、栈。使用数组实现。</li>
<li><strong>集</strong>：无序、数据不能重复。使用散列表实现。</li>
<li><strong>多重集</strong>：无序、数据可重复。可通过排序转换为列表。（不知道是什么鬼，没用过）</li>
<li><strong>数、图</strong>：略。</li>
</ul>
<h3 id="列表特点（变长数组）"><a href="#列表特点（变长数组）" class="headerlink" title="列表特点（变长数组）"></a>列表特点（变长数组）</h3><ul>
<li>变长。在不够长的时候通过数组拷贝的方式创建新数组。</li>
<li>拷贝的方式会造成性能耗损。</li>
<li>查询欠佳。</li>
<li>查询、修改的时间复杂度为O(n)。</li>
<li>查找顺序存储的结构类型，在数据量大的情况下，依旧是从0开始，一个个的去访问。效率很低。</li>
</ul>
<h3 id="何谓散列表"><a href="#何谓散列表" class="headerlink" title="何谓散列表"></a>何谓散列表</h3><ul>
<li>又称“<strong>哈希表</strong>”，能够通过key直接访问到具体元素。通过key访问一个映射表来得到value的地址。这个映射表也称为“<strong>散列函数</strong>”或者“<strong>哈希函数</strong>”。存放记录的数组叫做“<strong>散列表</strong>”。</li>
<li>通过不同的key，可能映射到相同的地址，这种现象叫做 “碰撞” 。</li>
<li>散列表有两种用法，一种是k=v，即set。另一种即map。</li>
</ul>
<h4 id="哈希函数的实现"><a href="#哈希函数的实现" class="headerlink" title="哈希函数的实现"></a>哈希函数的实现</h4><p>考虑因素：关键字的长度、哈希表的大小、关键字的分布情况、记录的查找频率等</p>
<ul>
<li><p><strong>直接寻址法</strong>：取关键字或者关键字的某个线性函数值作为散列地址。</p>
</li>
<li><p><strong>数字分析法</strong>：通过对数据的分析，发现冲突较小的部分，构造散列地址。</p>
</li>
<li><p><strong>取随机数法</strong>：取关键字的随机值作为散列地址。适用于关键字长度不一致的情况。</p>
</li>
</ul>
<h4 id="哈希函数冲突处理"><a href="#哈希函数冲突处理" class="headerlink" title="哈希函数冲突处理"></a>哈希函数冲突处理</h4><p>对不同的key进行hash运算，可能会出现相同的结果。处理如下：</p>
<ul>
<li><p><strong>开放地址法</strong>： 简单地讲，也就是说，一间厕所，来了一个顾客就蹲其对应的位置，如果又来一个顾客，把厕所单间门拉开，一看里面有位童鞋正在用劲，那么怎么办？很自然的，拉另一个单间的门，看看有人不，有的话就继续找坑。当然了，一般来说，这个顾客不会按顺序一个一个地拉厕所门，而是会去拉他认为有可能没有被占用的单间的门，这可以通过闻味道，听声音来辨别，这就是寻址查找算法。</p>
</li>
<li><p><strong>再哈希法</strong>：产生冲突后使用关键字的其他部分再次进行计算取址，如还是冲突则再用其它的部分hash。缺点：时间增加了。</p>
</li>
<li><strong>链地址法</strong>：在地址上做一个链表，存储。</li>
<li><strong>公共溢出区</strong>：建立一个公共溢出区。</li>
</ul>
<h4 id="散列表存储结构"><a href="#散列表存储结构" class="headerlink" title="散列表存储结构"></a>散列表存储结构</h4><ul>
<li>一个好的散列设计，除了一个良好的hash函数外，还要有好的冲突处理方式。一般选择链地址法。</li>
<li>数组 + 链表</li>
</ul>
<h4 id="散列表的特点"><a href="#散列表的特点" class="headerlink" title="散列表的特点"></a>散列表的特点</h4><ul>
<li>访问速度快：通过散列函数将key指定到一个地址上，所以在访问的时候不需要一个一个查找。增删改查都很快。（！！！！存疑，hash方法到底是得到一个数组index还是内存地址）</li>
<li>需要额外的空间：散列表实际上不太可能满载；额外空间处理冲突。</li>
<li>无序。</li>
<li>可能会产生碰撞，使得散列复杂。</li>
<li>数据量大（map快满载）时，性能下降。（冲突太多，在链表中太麻烦）</li>
</ul>
<h4 id="散列表的适用场景"><a href="#散列表的适用场景" class="headerlink" title="散列表的适用场景"></a>散列表的适用场景</h4><p>适合无序的，需要快速访问的情况。</p>
<ul>
<li>缓存。</li>
<li>快速查找。判断set中是否存在某指定元素</li>
</ul>
<h4 id="散列表性能分析"><a href="#散列表性能分析" class="headerlink" title="散列表性能分析"></a>散列表性能分析</h4><ul>
<li><p>如果没有冲突，通过对key进行hash寻址，完全是O(1)的效率，但是冲突在所难免。通常使用链地址法来处理冲突。碰撞之后需要遍历链表，时间复杂度为O(L)，L为链表长度。</p>
</li>
<li><p>当map负载很大的时候，说明大部分地址已经有值了，此时再添加元素，势必碰撞，势必走链表，于是性能下降。此时应当扩容，java的hashMap扩容因子为0.75，当负载达到75%的时候进行扩容。扩容之后进行大排版，也许之前在链表中存储，现在在数组中存储。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;何谓集合&quot;&gt;&lt;a href=&quot;#何谓集合&quot; class=&quot;headerlink&quot; title=&quot;何谓集合&quot;&gt;&lt;/a&gt;何谓集合&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基于数组的拓展，无长度限制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列表&lt;/strong&gt;：有序集合。链表、队列、栈
    
    </summary>
    
      <category term="算法夕拾" scheme="http://nudui.github.io/categories/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="存疑" scheme="http://nudui.github.io/tags/%E5%AD%98%E7%96%91/"/>
    
      <category term="算法" scheme="http://nudui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>golang笔记-4-函数</title>
    <link href="http://nudui.github.io/2016/11/17/golang%E7%AC%94%E8%AE%B0-4-%E5%87%BD%E6%95%B0/"/>
    <id>http://nudui.github.io/2016/11/17/golang笔记-4-函数/</id>
    <published>2016-11-17T15:14:54.000Z</published>
    <updated>2016-11-18T19:38:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>结构化最小模块单元，将复杂的算法过程分解为若干个较小任务，这些认为可在多处复用。<br><strong>函数是一等公民</strong></p>
<ul>
<li>无须前置声明。（未解其意，何谓“前置声明”）</li>
<li>不支持命名嵌套定义。（未解其意，何谓“命名嵌套定义”）</li>
<li>不支持同名函数重载。</li>
<li>不支持默认参数。（哪些语言的函数有默认参数，未解其意）</li>
<li>支持不定长变参。</li>
<li>支持<strong>多返回值</strong>。</li>
<li>支持命名返回值。</li>
<li>支持<strong>匿名函数</strong>与<strong>闭包</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func hello()&#123;</div><div class="line">    fmt.Println(&quot;hello world&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func exec(f func())&#123;    //函数作为参数</div><div class="line">    f()</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main()&#123;</div><div class="line">    h := hello  </div><div class="line">    exec(h)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数只能判断是否为nil，不能判断其他</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func a ()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func b()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func main()&#123;</div><div class="line">    fmt.Println(a == nil)     // 输出 false  </div><div class="line">    fmt.Pringln(a == b)       //报错，无效操作</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>无论是指针、引用类型还是其他类型参数，都是<strong>值传递</strong>。区别无非是<strong>拷贝</strong>目标对象还是拷贝指针。在函数内对参数进行操作，都不会影响原值。</li>
<li>在函数调用前，会为形参和返回值分配内存空间，并将实参拷贝到形参的内存上。</li>
</ul>
<h4 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h4><p>变参实际上是一个切片。只能接收同类型参数</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;结构化最小模块单元，将复杂的算法过程分解为若干个较小任务，这些认为可在多处复用。&lt;br&gt;&lt;strong&gt;函数是一等公民&lt;/strong&gt;&lt;/
    
    </summary>
    
      <category term="golang" scheme="http://nudui.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://nudui.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang笔记-3-表达式</title>
    <link href="http://nudui.github.io/2016/11/17/golang%E7%AC%94%E8%AE%B0-3-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://nudui.github.io/2016/11/17/golang笔记-3-表达式/</id>
    <published>2016-11-17T11:06:22.000Z</published>
    <updated>2016-11-17T15:10:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h5 id="25个关键字"><a href="#25个关键字" class="headerlink" title="25个关键字"></a>25个关键字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">break continue, if else , go chan , var const type </div><div class="line"></div><div class="line">for range , go goto defer , switch case default fallthrough</div><div class="line"></div><div class="line">package import , func struct return map select</div></pre></td></tr></table></figure>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if .. else .."></a>if .. else ..</h4><ul>
<li><p>表达式的值必须是bool类型。</p>
</li>
<li><p>表达式可以执行初始化语句。如下 :</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var x int </div><div class="line"></div><div class="line">func xinit()&#123;</div><div class="line">    x = 1000</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main()&#123;</div><div class="line">    if xinit(); x &gt; 100&#123;</div><div class="line">        ... //  可以执行</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h4><p>无须break，自动在相应的case处执行完毕中断</p>
<ul>
<li>一般形式 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func main()&#123;</div><div class="line">    a , b , c := 0 , 1 , 2</div><div class="line">    </div><div class="line">    switch x &#123;</div><div class="line">        case a , b : </div><div class="line">            fmt.Println(&quot;0 或者 1&quot;)</div><div class="line">        case 4 : </div><div class="line">            fmt.Println(&quot;值为4&quot;)</div><div class="line">        default : </div><div class="line">            fmt.Println(&quot;default value&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>表达式形式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func main()&#123;</div><div class="line">    a , b , c := 0 , 1 , 2</div><div class="line">    </div><div class="line">    switch x := 100 ; x &#123;</div><div class="line">        case a , b : </div><div class="line">            fmt.Println(&quot;0 或者 1&quot;)</div><div class="line">        case 4 : </div><div class="line">            fmt.Println(&quot;值为4&quot;)</div><div class="line">        default : </div><div class="line">            fmt.Println(&quot;default value&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>fallthrough   必须放在case块的末尾</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">func main()&#123;</div><div class="line">    </div><div class="line">    switch x := 100 ; x &#123;</div><div class="line">        case a , b : </div><div class="line">            fmt.Println(&quot;0 或者 1&quot;)</div><div class="line">        case 100 : </div><div class="line">            x += 10</div><div class="line">            fmt.Println(x)</div><div class="line">            </div><div class="line">            fallthrough     //无条件执行下一个case，default除外。</div><div class="line">        case 101 :</div><div class="line">            x += 10</div><div class="line">            fmt.Println(x)</div><div class="line">                            //如果还有fallthrough，则继续执行下一个非default的case</div><div class="line">        default : </div><div class="line">            fmt.Println(&quot;default value&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>不能出现重复的case。</li>
<li>有时switch可代替if语句。</li>
</ol>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ul>
<li>golang中只有for这一种循环。</li>
<li>for循环完成了java中的while循环、for..each循环。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//普通for循环</div><div class="line">for i := 0 ; i &lt; 100 ; i ++ &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//相当于while循环</div><div class="line">for x &lt; 10 &#123;</div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//相当于while true</div><div class="line">for &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>for range</strong> 用于数据迭代，支持字符串、数组、数组指针、切片、字典、通道类型、键值数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func main()&#123;</div><div class="line">    data := [10]int&#123;1, 2, 3, 4 &#125;</div><div class="line">    </div><div class="line">    for index , v := range data&#123;</div><div class="line">        fmt.Print(&quot;index is &quot; + index)</div><div class="line">        fmt.Println(&quot;value is &quot; + v)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关键字&quot;&gt;&lt;a href=&quot;#关键字&quot; class=&quot;headerlink&quot; title=&quot;关键字&quot;&gt;&lt;/a&gt;关键字&lt;/h3&gt;&lt;h5 id=&quot;25个关键字&quot;&gt;&lt;a href=&quot;#25个关键字&quot; class=&quot;headerlink&quot; title=&quot;25个关键字&quot;&gt;&lt;
    
    </summary>
    
      <category term="golang" scheme="http://nudui.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://nudui.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>大神 on Git</title>
    <link href="http://nudui.github.io/2016/11/17/%E5%A4%A7%E7%A5%9E-on-Git/"/>
    <id>http://nudui.github.io/2016/11/17/大神-on-Git/</id>
    <published>2016-11-17T06:02:11.000Z</published>
    <updated>2016-11-25T15:01:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="赵烨"><a href="#赵烨" class="headerlink" title="赵烨"></a>赵烨</h3><ul>
<li>java</li>
<li>《轻松学算法》。</li>
<li><a href="https://github.com/irfen" target="_blank" rel="external">https://github.com/irfen</a></li>
<li><a href="http://irfen.me" target="_blank" rel="external">http://irfen.me</a></li>
</ul>
<h3 id="无闻"><a href="#无闻" class="headerlink" title="无闻"></a>无闻</h3><ul>
<li>golang</li>
<li>GIT：<a href="https://github.com/Unknwon" target="_blank" rel="external">https://github.com/Unknwon</a></li>
</ul>
<h3 id="谢孟军"><a href="#谢孟军" class="headerlink" title="谢孟军"></a>谢孟军</h3><ul>
<li>《Go Web编程》、beego的作者</li>
<li><a href="https://github.com/astaxie" target="_blank" rel="external">https://github.com/astaxie</a></li>
<li><a href="http://edu.51cto.com/lecturer/index/user_id-6177767.html" target="_blank" rel="external">http://edu.51cto.com/lecturer/index/user_id-6177767.html</a></li>
</ul>
<h3 id="郝林"><a href="#郝林" class="headerlink" title="郝林"></a>郝林</h3><ul>
<li>《Go并发编程实战》作者</li>
<li><a href="https://github.com/g0hacker" target="_blank" rel="external">https://github.com/g0hacker</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;赵烨&quot;&gt;&lt;a href=&quot;#赵烨&quot; class=&quot;headerlink&quot; title=&quot;赵烨&quot;&gt;&lt;/a&gt;赵烨&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;java&lt;/li&gt;
&lt;li&gt;《轻松学算法》。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/irfe
    
    </summary>
    
      <category term="资源" scheme="http://nudui.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="资源" scheme="http://nudui.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Books on Git</title>
    <link href="http://nudui.github.io/2016/11/17/Books-on-Git/"/>
    <id>http://nudui.github.io/2016/11/17/Books-on-Git/</id>
    <published>2016-11-17T05:41:11.000Z</published>
    <updated>2016-11-18T19:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go入门指南"><a href="#Go入门指南" class="headerlink" title="Go入门指南"></a>Go入门指南</h3><ul>
<li><a href="https://github.com/nudui/the-way-to-go_ZH_CN" target="_blank" rel="external">https://github.com/nudui/the-way-to-go_ZH_CN</a></li>
</ul>
<h3 id="Go-Web编程"><a href="#Go-Web编程" class="headerlink" title="Go Web编程"></a>Go Web编程</h3><ul>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/tree/master/zh" target="_blank" rel="external">https://github.com/astaxie/build-web-application-with-golang/tree/master/zh</a></li>
</ul>
<h3 id="雨痕大神"><a href="#雨痕大神" class="headerlink" title="雨痕大神"></a>雨痕大神</h3><ul>
<li><a href="https://github.com/qyuhen/book" target="_blank" rel="external">https://github.com/qyuhen/book</a></li>
</ul>
<h3 id="国外资料整理"><a href="#国外资料整理" class="headerlink" title="国外资料整理"></a>国外资料整理</h3><ul>
<li><a href="https://github.com/dariubs/GoBooks#web-development" target="_blank" rel="external">https://github.com/dariubs/GoBooks#web-development</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Go入门指南&quot;&gt;&lt;a href=&quot;#Go入门指南&quot; class=&quot;headerlink&quot; title=&quot;Go入门指南&quot;&gt;&lt;/a&gt;Go入门指南&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nudui/the-way-to-go_
    
    </summary>
    
      <category term="资源" scheme="http://nudui.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="资源" scheme="http://nudui.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>golang笔记-2-指针</title>
    <link href="http://nudui.github.io/2016/11/17/golang%E7%AC%94%E8%AE%B0-2-%E6%8C%87%E9%92%88/"/>
    <id>http://nudui.github.io/2016/11/17/golang笔记-2-指针/</id>
    <published>2016-11-16T18:42:55.000Z</published>
    <updated>2016-11-18T02:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="指针与内存"><a href="#指针与内存" class="headerlink" title="指针与内存"></a>指针与内存</h3><p>不能将指针与内存地址混为一谈。</p>
<ul>
<li>内存地址：每个内存字节单元的唯一编号。</li>
<li>指针：专门用来保存地址的整形（整形？因为一切皆可用数字表示吗）变量。</li>
</ul>
<h6 id="如图："><a href="#如图：" class="headerlink" title="如图："></a>如图：</h6><table>
<thead>
<tr>
<th>表达式</th>
<th>p := &amp;x</th>
<th>x := 100</th>
</tr>
</thead>
<tbody>
<tr>
<td>memory</td>
<td>0x1200</td>
<td>100</td>
</tr>
<tr>
<td>address</td>
<td>0x800</td>
<td>0x1200</td>
</tr>
</tbody>
</table>
<h6 id="amp-与-："><a href="#amp-与-：" class="headerlink" title="&amp;与*："></a>&amp;与*：</h6><ul>
<li>取址运算符：&amp; ， 用于获取对象地址。</li>
<li>指针运算符：* ， 用于间接引用目标对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func main()&#123;</div><div class="line">    x := 10</div><div class="line">    p := &amp;x</div><div class="line">    fmt.Println(p)  //  0xc42000a298</div><div class="line">    fmt.Println(*p) //  10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><ul>
<li>支持相等运算。</li>
<li>不支持加减运算、类型转换。</li>
<li>如果两个指针指向同一个地址，则二指针相等</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;指针与内存&quot;&gt;&lt;a href=&quot;#指针与内存&quot; class=&quot;headerlink&quot; title=&quot;指针与内存&quot;&gt;&lt;/a&gt;指针与内存&lt;/h3&gt;&lt;p&gt;不能将指针与内存地址混为一谈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存地址：每个内存字节单元的唯一编号。&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="golang" scheme="http://nudui.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://nudui.github.io/tags/golang/"/>
    
      <category term="存疑" scheme="http://nudui.github.io/tags/%E5%AD%98%E7%96%91/"/>
    
  </entry>
  
  <entry>
    <title>算法夕拾（01）--数组</title>
    <link href="http://nudui.github.io/2016/11/16/%E6%8A%84%E4%B9%A6%E5%AD%A6%E7%AE%97%E6%B3%95%EF%BC%8801%EF%BC%89-%E6%95%B0%E7%BB%84/"/>
    <id>http://nudui.github.io/2016/11/16/抄书学算法（01）-数组/</id>
    <published>2016-11-16T14:38:11.000Z</published>
    <updated>2016-11-19T06:59:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何谓数组"><a href="#何谓数组" class="headerlink" title="何谓数组"></a>何谓数组</h3><ol>
<li>将 <strong>有限个同类型</strong> 的元素放在地址连续的内存中，以一个变量命名，通过序号进行访问指定元素。</li>
<li>使用前需要预估好长度，数组不能动态增长或者缩小。有余则费，不足无奈。</li>
</ol>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ol>
<li>确定一个值作为长度length。</li>
<li>根据声明的数据类型开辟内存空间（不同类型开辟的空间也不同）。</li>
<li>对内存空间的每一个元素都赋默认值。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int[] num = new int[10];   //每个值都为0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int[] num = new int[10];</div><div class="line">num[0] = 1;</div><div class="line">num[1] = 2;</div><div class="line">num[2] = 3;     //部分初始化</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int[] num = &#123;1, 2, 3&#125;   //显示初始化</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">num.length;     //length属性</div></pre></td></tr></table></figure>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><strong>长度固定</strong>。如果还想继续添加元素，只能另创一个数组。</li>
<li>顺序访问。必须从第1个元素开始访问，虽然编程中可以通过下标指定元素，但计算机在处理时还是顺序访问。</li>
</ol>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>由于长度固定，所以适用于不会变化的业务。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;何谓数组&quot;&gt;&lt;a href=&quot;#何谓数组&quot; class=&quot;headerlink&quot; title=&quot;何谓数组&quot;&gt;&lt;/a&gt;何谓数组&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;将 &lt;strong&gt;有限个同类型&lt;/strong&gt; 的元素放在地址连续的内存中，以一个变量命名，通过序号进行访问
    
    </summary>
    
      <category term="算法夕拾" scheme="http://nudui.github.io/categories/%E7%AE%97%E6%B3%95%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="算法" scheme="http://nudui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
